-A LiveView process is a process that receives events as messages, updates its state accordingly, renders a template, and sends back the diffs
-Events can be sent externally by the browser(handle_event), or be sent internally by the LiveView itself or any other Elixir process(handle_info)

Lesson 3 - Button Clicks
-LiveView's have 3 primary callback functions
-mount, render and handle_event
    -mount assigns state to the socket
    -render renders the page using html code and can include eex tags and embedded phoenix
    -handle_event handles events that are sent from render(for example button clicks)
-In this lesson we build a light bar that can be increased/decreased with buttons

Lesson 4 - LiveView Life Cycle
-Initial HTTP request send a HTML page back
-WebSocket is opened and spawns a LiveView Process which can react to events and update the page dynamically

Lesson 5 - Dynamic Form 
-Shows us how to update the page dynamically as we change input values on the page.
-Change light bar from lesson 3 to use a slider instead of up and down buttons
    -Add option to change colors of the light as well

Lesson 6 - Dashboard
-Update page internally, rather than external input by the user
-Send self message after server is connected
    -Use hande_info to update "sales" values on the page to random numbers

Lesson 7 - Search
-Create a search bar for flights using phoenix that uses external input by the user to search values from database
-Also included a loading indicator while waiting for results to show
-Excercise: Implement search for finding a vehicle make or model

Lesson 8 - Autocomplete
-Implemented autocomplete feature into phoenix LiveView(vehicle and flights from last lesson)
    -Suggestions from Elixir file(pre-prepared by the course)

Lesson 9 - Filtering
-Filter boats by type(sporting, fishing and sailing) and price range(low, medium, high)
-Use Ecto to query database of boats
-Use temporary_assigns: to reset data if we don't need to keep information in process memory(just need to render it)
    -Minimizes memory usage on the server
-Exercise: Implement filter for atheles(filter by sport and status)

Lesson 10 - Function Components
-Use function component
    -Takes assigns and returns a heex template
-Useful for managing duplication of markup and styles
-Can render function components inside function components
-Used to make code more readable

Lesson 11 - Live Navigation
-Implement navigation to different url's while keeping the same LiveView process and state
    -Also redirection(shut down current LiveView and mount a new one using same layout)
    -Same websocket connection
-2 Ways to do live navigation
    -navigate to dismount current LiveView and mount new one - Used when you want to navigate to a different LiveView
    -patch to patch state of current LiveView and update URL - Used when you want to navigate to the same LiveView process
-Change page title based on URL

Lesson 12 - Sorting
-Implement sorting for a database, either by id, item name, quantity, etc.(can also sort by ascending or descending)
    -Default values implemented as well
-Sorting parameters shown in the url

Lesson 13 - Paginations
-Add paginations to a database as well as the option to set the number of items per page
-Add way to navigate to previous and next page to view items
-Pagination options stored in url so each page is easy to share and bookmark

Lesson 14 - Live Ecto Forms and Lists
-Add check in system(adds name & phone number to a database)
    -Add validation(check for valid phone number and name to be more than 2 characters)
-Create a form from a map
    -to_form to convert an Ecto changeset into a form data structure

Lesson 15 - Live validation
-Change form to validate as the user is inputting the information

Lesson 16 - Streams
-If we expect a lot of inserts in the database to happen
    -We don't want the data to be kept in memory as part of the LiveView state
    -We want to prepend to list shown in the browser and not keep them on memory in server
-Use streams instead of assign
    -Assigns a new stream to socket
    -html code needs to be wrapped in parent container with phx-change="stream"
-Rather than calling update on socket use stream_insert
-Stream vs temporary_assigns:
    -temporary_assigns for static data that only needs to be rendered
    -Streams for collections of items that you don't want to hold in memory but need to update collection after

Lesson 17 - Toggling State
-Add toggling of state to page from previous lesson
-phx-value-* to fetch value when clicking button
-Add functionality to the check out option of the previous page we built(check in page for volunteers)
    -Page status automatically updated when person checks out(name is greyed and button changes to "Check In")
-Insert updated check_out status into stream
-Streams lets us update, delete or add items from large collections without needing to fetch items from database after initial render
-Add toggling of server status(server LiveView from previous lesson)